<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ’æœŸå®¡æ ¸å¯¹æ¯”å·¥å…· - è¿è¥ç­–åˆ’å·¥å…·ç«™</title>
<script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
:root {
  --primary: #6366f1;
  --primary-hover: #4f46e5;
  --bg: #0f172a;
  --card: #1e293b;
  --card-hover: #334155;
  --text: #e2e8f0;
  --text-secondary: #94a3b8;
  --border: #334155;
  --success: #22c55e;
  --warning: #f59e0b;
  --danger: #ef4444;
  --info: #3b82f6;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  line-height: 1.6;
}
.container { max-width: 1100px; margin: 0 auto; padding: 24px 20px; }
header {
  text-align: center;
  padding: 32px 0 24px;
}
header h1 {
  font-size: 28px;
  background: linear-gradient(135deg, #818cf8, #c084fc);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 8px;
}
header p { color: var(--text-secondary); font-size: 14px; }
.back-link {
  display: inline-block;
  color: var(--text-secondary);
  text-decoration: none;
  font-size: 13px;
  margin-bottom: 16px;
  transition: color .2s;
}
.back-link:hover { color: var(--primary); }

/* Steps */
.steps {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin-bottom: 32px;
}
.step {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 20px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 500;
  background: var(--card);
  color: var(--text-secondary);
  border: 1px solid var(--border);
  transition: all .3s;
}
.step.active {
  background: var(--primary);
  color: #fff;
  border-color: var(--primary);
}
.step.done {
  background: rgba(34,197,94,.15);
  color: var(--success);
  border-color: rgba(34,197,94,.3);
}
.step-num {
  width: 22px; height: 22px;
  border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 12px; font-weight: 700;
  background: rgba(255,255,255,.15);
}
.step.done .step-num { background: var(--success); color: #fff; }

/* Card */
.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 24px;
  margin-bottom: 20px;
}
.card h2 {
  font-size: 16px;
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}
.card h2 .icon { font-size: 20px; }

/* Upload */
.upload-zone {
  border: 2px dashed var(--border);
  border-radius: 10px;
  padding: 32px;
  text-align: center;
  cursor: pointer;
  transition: all .3s;
  position: relative;
  overflow: hidden;
}
.upload-zone:hover, .upload-zone.dragover {
  border-color: var(--primary);
  background: rgba(99,102,241,.05);
}
.upload-zone.has-file {
  border-color: var(--success);
  background: rgba(34,197,94,.05);
}
.upload-zone input[type="file"] {
  position: absolute; inset: 0;
  opacity: 0; cursor: pointer;
}
.upload-zone .icon-upload { font-size: 36px; margin-bottom: 8px; }
.upload-zone .label { font-size: 14px; color: var(--text-secondary); }
.upload-zone .filename {
  font-size: 14px; color: var(--success);
  font-weight: 500; margin-top: 4px;
}
.upload-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }

/* Config */
.config-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
  flex-wrap: wrap;
}
.config-row label {
  font-size: 13px;
  color: var(--text-secondary);
  min-width: 100px;
}
.config-row input, .config-row select {
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 13px;
  flex: 1;
  min-width: 0;
}
.config-row input:focus, .config-row select:focus {
  outline: none;
  border-color: var(--primary);
}

/* Buttons */
.btn {
  padding: 10px 28px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all .2s;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}
.btn-primary {
  background: var(--primary);
  color: #fff;
}
.btn-primary:hover { background: var(--primary-hover); }
.btn-primary:disabled {
  opacity: .4;
  cursor: not-allowed;
}
.btn-secondary {
  background: var(--card-hover);
  color: var(--text);
  border: 1px solid var(--border);
}
.btn-secondary:hover { background: rgba(255,255,255,.1); }
.btn-group {
  display: flex;
  gap: 12px;
  justify-content: center;
  margin-top: 20px;
}

/* Mapping table */
.mapping-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
  margin-top: 12px;
}
.mapping-table th {
  background: var(--bg);
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  border-bottom: 1px solid var(--border);
}
.mapping-table td {
  padding: 8px 12px;
  border-bottom: 1px solid rgba(51,65,85,.5);
  vertical-align: top;
}
.mapping-table tr:hover td { background: rgba(99,102,241,.04); }
.mapping-table select {
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  width: 100%;
  max-width: 300px;
}
.tag {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 500;
}
.tag-match { background: rgba(34,197,94,.15); color: var(--success); }
.tag-miss { background: rgba(239,68,68,.15); color: var(--danger); }
.tag-warn { background: rgba(245,158,11,.15); color: var(--warning); }
.tag-info { background: rgba(99,102,241,.15); color: var(--info); }

/* Report */
.report-content {
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 24px 28px;
  line-height: 1.8;
  overflow-x: auto;
}
.report-content h1 { font-size: 22px; margin: 16px 0 8px; color: #c4b5fd; }
.report-content h2 { font-size: 18px; margin: 20px 0 10px; color: #a5b4fc; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
.report-content h3 { font-size: 15px; margin: 16px 0 8px; color: #818cf8; }
.report-content h4 { font-size: 14px; margin: 12px 0 6px; }
.report-content blockquote {
  border-left: 3px solid var(--primary);
  padding: 4px 16px;
  margin: 8px 0;
  color: var(--text-secondary);
  font-size: 13px;
}
.report-content table {
  width: 100%;
  border-collapse: collapse;
  margin: 10px 0;
  font-size: 13px;
}
.report-content th {
  background: rgba(99,102,241,.1);
  padding: 8px 10px;
  text-align: left;
  font-weight: 600;
  border: 1px solid var(--border);
  white-space: nowrap;
}
.report-content td {
  padding: 6px 10px;
  border: 1px solid rgba(51,65,85,.5);
}
.report-content tr:nth-child(even) td { background: rgba(30,41,59,.5); }
.report-content hr { border: none; border-top: 1px solid var(--border); margin: 16px 0; }
.report-content strong { color: #fbbf24; }
.report-content code { background: rgba(99,102,241,.15); padding: 2px 6px; border-radius: 3px; font-size: 12px; }

/* Loading */
.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 40px;
  color: var(--text-secondary);
}
.spinner {
  width: 24px; height: 24px;
  border: 3px solid var(--border);
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: spin .8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Responsive */
@media (max-width: 640px) {
  .upload-grid { grid-template-columns: 1fr; }
  .steps { flex-wrap: wrap; }
  .report-content { padding: 16px; }
}

/* Section visibility */
.section { display: none; }
.section.visible { display: block; }
</style>
</head>
<body>
<div class="container">
  <a href="./" class="back-link">&larr; è¿”å›å·¥å…·ç«™é¦–é¡µ</a>
  <header>
    <h1>æ’æœŸå®¡æ ¸å¯¹æ¯”å·¥å…·</h1>
    <p>ä¸Šä¼ æ’æœŸå®¡æ ¸è¡¨(xlsx) + æ­£å¼ä¸Šçº¿è¡¨(csv)ï¼Œè‡ªåŠ¨ç”Ÿæˆä¸‰ç»´å®¡æ ¸æŠ¥å‘Š</p>
  </header>

  <!-- Steps indicator -->
  <div class="steps">
    <div class="step active" id="step1-indicator">
      <span class="step-num">1</span> ä¸Šä¼ æ–‡ä»¶
    </div>
    <div class="step" id="step2-indicator">
      <span class="step-num">2</span> ç¡®è®¤æ˜ å°„
    </div>
    <div class="step" id="step3-indicator">
      <span class="step-num">3</span> æŸ¥çœ‹æŠ¥å‘Š
    </div>
  </div>

  <!-- Step 1: Upload -->
  <div class="section visible" id="step1">
    <div class="card">
      <h2><span class="icon">ğŸ“</span> ä¸Šä¼ æ–‡ä»¶</h2>
      <div class="upload-grid">
        <div class="upload-zone" id="zone-xlsx">
          <input type="file" accept=".xlsx,.xls" id="file-xlsx">
          <div class="icon-upload">ğŸ“Š</div>
          <div class="label">æ’æœŸå®¡æ ¸è¡¨ (.xlsx)</div>
          <div class="filename" id="name-xlsx"></div>
        </div>
        <div class="upload-zone" id="zone-csv">
          <input type="file" accept=".csv" id="file-csv">
          <div class="icon-upload">ğŸ“‹</div>
          <div class="label">æ­£å¼ä¸Šçº¿è¡¨ (.csv)</div>
          <div class="filename" id="name-csv"></div>
        </div>
      </div>
    </div>
    <div class="card">
      <h2><span class="icon">âš™ï¸</span> é…ç½®</h2>
      <div class="config-row">
        <label>èŠ‚æ—¥åç§°</label>
        <input type="text" id="cfg-holiday" placeholder="å¦‚ï¼š2026æƒ…äººèŠ‚" value="">
      </div>
      <div class="config-row">
        <label>èŠ‚æ—¥å…³é”®è¯</label>
        <input type="text" id="cfg-keywords" placeholder="é€—å·åˆ†éš”ï¼Œå¦‚ï¼šæƒ…äºº,valentine" value="">
      </div>
      <div class="config-row">
        <label>æ´»åŠ¨åˆ«å</label>
        <input type="text" id="cfg-aliases" placeholder='JSONæ ¼å¼ï¼Œå¦‚ï¼š{"åˆæˆå°æ¸¸æˆ":"æŒ–çŸ¿"}' value='{"åˆæˆå°æ¸¸æˆ":"æŒ–çŸ¿"}'>
      </div>
      <div class="config-row">
        <label>CSVç¼–ç </label>
        <select id="cfg-encoding">
          <option value="gbk" selected>GBK</option>
          <option value="utf-8">UTF-8</option>
          <option value="gb18030">GB18030</option>
        </select>
      </div>
    </div>
    <div class="btn-group">
      <button class="btn btn-primary" id="btn-analyze" disabled onclick="startAnalysis()">
        å¼€å§‹åˆ†æ
      </button>
    </div>
  </div>

  <!-- Step 2: Mapping -->
  <div class="section" id="step2">
    <div class="card">
      <h2><span class="icon">ğŸ”—</span> æ´»åŠ¨æ˜ å°„ç¡®è®¤</h2>
      <p style="font-size:13px;color:var(--text-secondary);margin-bottom:12px;">
        ç³»ç»Ÿå·²è‡ªåŠ¨åŒ¹é…ï¼Œè¯·æ£€æŸ¥å¹¶è°ƒæ•´ã€‚æ¯è¡Œå¯é€‰æ‹©å¤šä¸ªä¸Šçº¿è¡¨æ´»åŠ¨ï¼ˆæŒ‰ä½Ctrlå¤šé€‰ï¼‰ã€‚
      </p>
      <div id="mapping-container"></div>
    </div>
    <div class="btn-group">
      <button class="btn btn-secondary" onclick="goStep(1)">ä¸Šä¸€æ­¥</button>
      <button class="btn btn-primary" onclick="confirmMapping()">ç¡®è®¤å¹¶ç”ŸæˆæŠ¥å‘Š</button>
    </div>
  </div>

  <!-- Step 3: Report -->
  <div class="section" id="step3">
    <div class="card">
      <h2><span class="icon">ğŸ“„</span> å®¡æ ¸æŠ¥å‘Š</h2>
      <div class="btn-group" style="margin-top:0;margin-bottom:16px;justify-content:flex-end;">
        <button class="btn btn-secondary" onclick="copyReport()">ğŸ“‹ å¤åˆ¶ Markdown</button>
        <button class="btn btn-secondary" onclick="downloadReport()">â¬‡ ä¸‹è½½ .md</button>
      </div>
      <div class="report-content" id="report-output"></div>
    </div>
    <div class="btn-group">
      <button class="btn btn-secondary" onclick="goStep(2)">è¿”å›æ˜ å°„</button>
      <button class="btn btn-secondary" onclick="goStep(1)">é‡æ–°å¼€å§‹</button>
    </div>
  </div>

  <!-- Loading overlay -->
  <div class="section" id="loading">
    <div class="loading">
      <div class="spinner"></div>
      <span id="loading-text">æ­£åœ¨è§£ææ–‡ä»¶...</span>
    </div>
  </div>
</div>

<script>
// ============================
// Constants
// ============================
const CFG = {
  SERVER_FULL: 130,
  SERVER_FULL_GRAY: 142,
  SERVER_S6: 77,
  SERVER_S35: 53,
  GRAY_EXTRA: 12,
  DEPLOY_OFFSET: 1,
  XLSX_ROW_DATE_SERIAL: 3,
  XLSX_ROW_DATA_START: 4,
  XLSX_COL_DATE_START: 11,
  XLSX_COL_DATE_END: 34,
};

// State
let xlsxFile = null, csvFile = null;
let xlsxData = null, csvData = null;
let currentMapping = {};
let reportMarkdown = '';

// ============================
// File Upload Handling
// ============================
document.getElementById('file-xlsx').addEventListener('change', e => {
  xlsxFile = e.target.files[0];
  if (xlsxFile) {
    document.getElementById('name-xlsx').textContent = 'âœ… ' + xlsxFile.name;
    document.getElementById('zone-xlsx').classList.add('has-file');
  }
  checkReady();
});

document.getElementById('file-csv').addEventListener('change', e => {
  csvFile = e.target.files[0];
  if (csvFile) {
    document.getElementById('name-csv').textContent = 'âœ… ' + csvFile.name;
    document.getElementById('zone-csv').classList.add('has-file');
  }
  checkReady();
});

function checkReady() {
  document.getElementById('btn-analyze').disabled = !(xlsxFile && csvFile);
}

// ============================
// Step Navigation
// ============================
function goStep(n) {
  ['step1','step2','step3','loading'].forEach(id => {
    document.getElementById(id).classList.remove('visible');
  });
  document.getElementById('step' + n).classList.add('visible');
  for (let i = 1; i <= 3; i++) {
    const el = document.getElementById('step' + i + '-indicator');
    el.classList.remove('active','done');
    if (i < n) el.classList.add('done');
    else if (i === n) el.classList.add('active');
  }
  window.scrollTo({top: 0, behavior: 'smooth'});
}

function showLoading(text) {
  document.getElementById('loading-text').textContent = text;
  ['step1','step2','step3'].forEach(id => document.getElementById(id).classList.remove('visible'));
  document.getElementById('loading').classList.add('visible');
}

// ============================
// Excel Parsing
// ============================
function parseXlsx(buffer) {
  const wb = XLSX.read(buffer, { type: 'array' });
  const ws = wb.Sheets[wb.SheetNames[0]];
  const raw = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });

  // Parse date columns (row 3 = date serials)
  const dateMap = {};
  for (let col = CFG.XLSX_COL_DATE_START; col < Math.min(CFG.XLSX_COL_DATE_END, (raw[3] || []).length); col++) {
    const serial = raw[3][col];
    if (serial && !isNaN(serial)) {
      dateMap[col] = excelDateToJS(Number(serial));
    }
  }

  // Parse activities (row 4+)
  const activities = {};
  for (let r = CFG.XLSX_ROW_DATA_START; r < raw.length; r++) {
    const row = raw[r];
    const name = String(row[0] || '').trim();
    if (!name) continue;

    const person = String(row[1] || '').trim();
    const crossServer = String(row[3] || '').trim();
    const serverCount = row[5];
    const actCount = row[8];

    // Collect date marks
    const activeDates = [];
    const markDetails = [];
    for (let col = CFG.XLSX_COL_DATE_START; col < Math.min(CFG.XLSX_COL_DATE_END, row.length); col++) {
      const val = row[col];
      if (val !== '' && val !== false && val !== 0 && String(val).trim() !== '' && String(val) !== 'false' && String(val) !== '0') {
        const dt = dateMap[col];
        if (dt) {
          activeDates.push(dt);
          markDetails.push(fmtDate(dt, 'MM.DD') + '(' + String(val).trim() + ')');
        }
      }
    }

    activities[name] = {
      person, crossServer, serverCount, actCount,
      activeDates, markDetails,
      start: activeDates.length ? new Date(Math.min(...activeDates.map(d => d.getTime()))) : null,
      end: activeDates.length ? new Date(Math.max(...activeDates.map(d => d.getTime()))) : null,
    };
  }
  return { dateMap, activities };
}

function excelDateToJS(serial) {
  return new Date(Math.round((serial - 25569) * 86400 * 1000));
}

// ============================
// CSV Parsing
// ============================
function parseCsv(buffer) {
  const encoding = document.getElementById('cfg-encoding').value;
  let text;
  try {
    text = new TextDecoder(encoding).decode(buffer);
  } catch {
    text = new TextDecoder('utf-8').decode(buffer);
  }

  const lines = text.split('\n').map(l => l.trim()).filter(l => l);
  if (lines.length < 2) return {};

  const activities = {};
  for (let i = 1; i < lines.length; i++) {
    const cols = parseCSVLine(lines[i]);
    if (cols.length < 8) continue;

    const clean = s => s.replace(/\t/g, '').trim();
    const actId = clean(cols[0]);
    const actName = clean(cols[1]);
    const serversRaw = clean(cols[2]);
    const crossRank = clean(cols[3]);
    const crossServer = clean(cols[4]);
    const startTime = clean(cols[5]);
    const endTime = clean(cols[6]);
    const duration = clean(cols[7]);

    // Parse servers
    const groupMatch = serversRaw.match(/^(\d+)ç»„/);
    const numGroups = groupMatch ? parseInt(groupMatch[1]) : 0;
    const allServers = new Set(serversRaw.match(/\d{7}/g) || []);

    if (!activities[actName]) activities[actName] = [];
    activities[actName].push({
      id: actId, startTime, endTime, duration,
      crossRank, crossServer,
      numGroups, numServers: allServers.size, allServers,
    });
  }
  return activities;
}

function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (inQuotes) {
      if (ch === '"' && line[i + 1] === '"') { current += '"'; i++; }
      else if (ch === '"') inQuotes = false;
      else current += ch;
    } else {
      if (ch === '"') inQuotes = true;
      else if (ch === ',') { result.push(current); current = ''; }
      else current += ch;
    }
  }
  result.push(current);
  return result;
}

// ============================
// Auto Matching
// ============================
function autoMatch(xlsxActs, csvActs) {
  const aliases = getAliases();
  const csvNames = Object.keys(csvActs);
  const mapping = {};
  const usedCsv = new Set();

  for (const xName of Object.keys(xlsxActs)) {
    const matches = [];
    const xLower = xName.toLowerCase();
    const xKeywords = extractKeywords(xName);

    for (const cName of csvNames) {
      const cLower = cName.toLowerCase();
      let score = 0;

      // Direct substring
      if (xLower.includes(cLower) || cLower.includes(xLower)) { score = 100; }

      // Keyword matching
      if (score === 0) {
        const cKeywords = extractKeywords(cName);
        for (const kw of xKeywords) {
          if (kw.length >= 2) {
            if (cLower.includes(kw)) score += 20;
            for (const ck of cKeywords) {
              if (ck === kw) score += 15;
            }
          }
        }
      }

      // Alias matching
      if (score === 0) {
        for (const [alias, real] of Object.entries(aliases)) {
          if (xLower.includes(real.toLowerCase()) && cLower.includes(alias.toLowerCase())) {
            score = 90;
          }
          if (xLower.includes(alias.toLowerCase()) && cLower.includes(real.toLowerCase())) {
            score = 90;
          }
        }
      }

      if (score >= 20) matches.push({ name: cName, score });
    }

    // Sort by score, take all with score >= 30
    matches.sort((a, b) => b.score - a.score);
    const selected = matches.filter(m => m.score >= 30).map(m => m.name);
    mapping[xName] = selected;
    selected.forEach(n => usedCsv.add(n));
  }

  // Check unmatched CSV activities
  const unmatchedCsv = csvNames.filter(n => !usedCsv.has(n));

  // Try to assign unmatched CSV to existing xlsx via aliases
  for (const cName of unmatchedCsv) {
    const cLower = cName.toLowerCase();
    for (const [alias, real] of Object.entries(aliases)) {
      if (cLower.includes(alias.toLowerCase())) {
        // Find xlsx activity that matches the real name
        for (const xName of Object.keys(mapping)) {
          if (xName.toLowerCase().includes(real.toLowerCase())) {
            if (!mapping[xName].includes(cName)) {
              mapping[xName].push(cName);
            }
          }
        }
      }
    }
  }

  return mapping;
}

function extractKeywords(name) {
  const noise = ['èŠ‚æ—¥','é€šç”¨','æ´»åŠ¨','2025','2026','schema','schema6','schema3','ç¬¬','æœŸ',
    'ï¼ˆ','ï¼‰','(',')','-','_','+','ã€',' ','ä¸ç°','è·¨æœ','å…¨æœ','åˆ†ç»„','å•æœ',
    'ç¬¬ä¸€','ç¬¬äºŒ','ç¬¬ä¸‰','ç¬¬å››','ç¬¬äº”'];
  let s = name.toLowerCase();
  for (const n of noise) s = s.replace(new RegExp(escapeRegex(n), 'g'), ' ');
  return s.split(/\s+/).filter(w => w.length >= 2);
}

function escapeRegex(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
function getAliases() {
  try { return JSON.parse(document.getElementById('cfg-aliases').value); }
  catch { return {}; }
}

// ============================
// Analysis Functions
// ============================
function isBugui(name) { return name.includes('ä¸ç°'); }

function expectedServerCount(xName, isS6, isS35) {
  if (isBugui(xName)) {
    if (isS6) return CFG.SERVER_S6 + CFG.GRAY_EXTRA;
    if (isS35) return CFG.SERVER_S35;
    return CFG.SERVER_FULL_GRAY;
  }
  if (isS6) return CFG.SERVER_S6;
  if (isS35) return CFG.SERVER_S35;
  return CFG.SERVER_FULL;
}

function auditAll(xlsxActs, csvActs, mapping) {
  const results = {
    matched: [], xlsxMissing: [], csvMissing: [],
    timeWithMarks: [], timeWithoutMarks: [],
    crossMismatch: [], serverIssues: [], schemaSplits: [],
    namingIssues: [],
  };

  const allMatchedCsv = new Set();

  // --- Activity Matching ---
  for (const [xName, csvNames] of Object.entries(mapping)) {
    if (!xlsxActs[xName]) continue;
    const xa = xlsxActs[xName];

    if (!csvNames || csvNames.length === 0) {
      results.xlsxMissing.push({ name: xName, person: xa.person, note: 'ä¸Šçº¿è¡¨ä¸­æ— å¯¹åº”æ¡ç›®' });
      continue;
    }

    let totalCount = 0;
    const items = [];
    let foundAny = false;

    for (const cn of csvNames) {
      if (csvActs[cn]) {
        foundAny = true;
        csvActs[cn].forEach(it => {
          items.push({ csvName: cn, id: it.id, start: it.startTime, end: it.endTime });
          totalCount++;
        });
        allMatchedCsv.add(cn);
      }
    }

    if (foundAny) {
      results.matched.push({ xName, person: xa.person, items, count: totalCount });
    } else {
      results.xlsxMissing.push({ name: xName, person: xa.person, note: 'æ˜ å°„ç›®æ ‡åœ¨ä¸Šçº¿è¡¨ä¸­æœªæ‰¾åˆ°' });
    }

    // --- Time comparison ---
    const csvItems = [];
    for (const cn of csvNames) {
      if (csvActs[cn]) csvActs[cn].forEach(it => csvItems.push({ name: cn, ...it }));
    }

    if (xa.activeDates.length > 0 && csvItems.length > 0) {
      const comparisons = [];
      csvItems.sort((a, b) => a.startTime.localeCompare(b.startTime));

      for (const ci of csvItems) {
        const csvStart = parseDateStr(ci.startTime);
        let matchResult = 'âš ï¸ æ— æ³•æ¯”å¯¹';

        if (csvStart) {
          const deployDay = new Date(csvStart.getTime() - CFG.DEPLOY_OFFSET * 86400000);
          const schedDates = xa.activeDates.map(d => d.toDateString());

          if (schedDates.includes(deployDay.toDateString())) {
            matchResult = `âœ… åŒ¹é…ï¼ˆæ’æœŸ${fmtDate(deployDay,'MM.DD')} â†’ ä¸Šçº¿${fmtDate(csvStart,'MM.DD')}ï¼Œ+${CFG.DEPLOY_OFFSET}å¤©ï¼‰`;
          } else if (xa.start && xa.end) {
            const rangeEnd = new Date(xa.end.getTime() + 86400000);
            if (csvStart >= xa.start && csvStart <= rangeEnd) {
              matchResult = 'âœ… åœ¨æ’æœŸè¦†ç›–èŒƒå›´å†…';
            } else {
              const diff = Math.round((csvStart - xa.start) / 86400000);
              matchResult = `âŒ è¶…å‡ºæ’æœŸèŒƒå›´ï¼ˆå·®${diff > 0 ? '+' : ''}${diff}å¤©ï¼‰`;
            }
          }
        }
        comparisons.push({ csvName: ci.name, csvId: ci.id, start: ci.startTime, end: ci.endTime, duration: ci.duration, result: matchResult });
      }
      results.timeWithMarks.push({ xName, person: xa.person, marks: xa.markDetails, comparisons });
    } else if (csvItems.length > 0) {
      for (const ci of csvItems) {
        results.timeWithoutMarks.push({ xName, csvName: ci.name, csvId: ci.id, start: ci.startTime, end: ci.endTime, duration: ci.duration });
      }
    }

    // --- Server comparison ---
    for (const cn of csvNames) {
      if (!csvActs[cn]) continue;
      const item = csvActs[cn][0];

      // Cross type check
      const xCross = xa.crossServer;
      const cCross = item.crossServer;
      if (xCross === 'å•æœ' && cCross !== 'å•æœ') {
        results.crossMismatch.push({ xName, csvName: cn, xCross, cCross: `${cCross}(${item.numGroups}ç»„/${item.numServers}æœ)`, note: 'æ’æœŸ=å•æœï¼Œä¸Šçº¿â‰ å•æœ' });
      } else if (xCross.includes('è·¨æœ') && cCross !== 'è·¨æœ') {
        results.crossMismatch.push({ xName, csvName: cn, xCross, cCross: `${cCross}(${item.numServers}æœ)`, note: `æ’æœŸ=${xCross}ï¼Œä¸Šçº¿=${cCross}` });
      }

      // Server count check
      const isS6 = /schema6|_s6|-s6/i.test(cn);
      const isS35 = /schema3|s3-5|schema3~5/i.test(cn);
      const expected = expectedServerCount(xName, isS6, isS35);
      if (item.numServers !== expected && item.numServers > 0) {
        let note = `é¢„æœŸ${expected}ï¼Œå®é™…${item.numServers}ï¼ˆå·®${item.numServers - expected > 0 ? '+' : ''}${item.numServers - expected}ï¼‰`;
        if (isBugui(xName) && item.numServers === CFG.SERVER_FULL) {
          note = `"ä¸ç°"æ´»åŠ¨åº”æœ‰${CFG.SERVER_FULL_GRAY}æœ(å«ç°åº¦)ï¼Œå®é™…åªæœ‰${CFG.SERVER_FULL}`;
        } else if (isBugui(xName) && item.numServers === CFG.SERVER_FULL_GRAY) {
          continue; // Normal for bugui
        }
        results.serverIssues.push({ xName, csvName: cn, csvId: item.id, expected, actual: item.numServers, diff: item.numServers - expected, note });
      }
    }
  }

  // CSV missing
  for (const cn of Object.keys(csvActs)) {
    if (!allMatchedCsv.has(cn)) {
      results.csvMissing.push({ name: cn, count: csvActs[cn].length, ids: csvActs[cn].map(i => i.id) });
    }
  }

  // Schema split check
  const schemaPairs = findSchemaPairs(csvActs);
  for (const [s6, s35] of schemaPairs) {
    const s6Servers = csvActs[s6][0].allServers;
    const s35Servers = csvActs[s35][0].allServers;
    const overlap = new Set([...s6Servers].filter(x => s35Servers.has(x)));
    const combined = new Set([...s6Servers, ...s35Servers]);
    results.schemaSplits.push({ s6, s35, s6Count: s6Servers.size, s35Count: s35Servers.size, combined: combined.size, overlap: overlap.size, ok: overlap.size === 0 });
  }

  // Naming check
  const keywords = (document.getElementById('cfg-keywords').value || '').split(',').map(s => s.trim()).filter(Boolean);
  const allHolidays = ['åœ£è¯','ä¸‡åœ£','æ„Ÿæ©','ç™»æœˆ','å¤æ—¥','æ˜¥èŠ‚','æ–°å¹´','ä¸­ç§‹','å›½åº†','ç«¯åˆ','å…ƒæ—¦','å¤æ´»'];
  const otherHolidays = allHolidays.filter(h => !keywords.some(k => h.includes(k) || k.includes(h)));
  const currentYear = new Date().getFullYear().toString();

  for (const [name, items] of Object.entries(csvActs)) {
    for (const h of otherHolidays) {
      if (name.includes(h)) {
        results.namingIssues.push({ csvName: name, ids: items.map(i => i.id), issue: `åç§°åŒ…å«"${h}"ï¼Œå¯èƒ½æ˜¯æ—§æ¨¡æ¿` });
        break;
      }
    }
    const yearMatches = name.match(/20\d{2}/g) || [];
    for (const y of yearMatches) {
      if (y !== currentYear) {
        results.namingIssues.push({ csvName: name, ids: items.map(i => i.id), issue: `å¹´ä»½ä¸º${y}ï¼Œå½“å‰ä¸º${currentYear}` });
      }
    }
  }

  return results;
}

function findSchemaPairs(csvActs) {
  const pairs = [];
  const names = Object.keys(csvActs);
  const s6Names = names.filter(n => /schema6|_schema6|-s6/i.test(n));
  const s35Names = names.filter(n => /schema3|s3-5|schema3~5/i.test(n));

  for (const s6 of s6Names) {
    const base = s6.toLowerCase().replace(/schema6|_schema6|-schema6|-s6/gi, '').replace(/[-_ ]+/g, '');
    for (const s35 of s35Names) {
      const s35Base = s35.toLowerCase().replace(/schema3-5|schema3~5|_schema3-5|-s3-5|-schema3-5|schema3|schema4|schema5/gi, '').replace(/[-_ ]+/g, '');
      if (base === s35Base) {
        pairs.push([s6, s35]);
        break;
      }
    }
  }
  return pairs;
}

// ============================
// Report Generation
// ============================
function generateReport(results) {
  const holiday = document.getElementById('cfg-holiday').value || 'èŠ‚æ—¥';
  const today = new Date().toLocaleDateString('zh-CN', { year:'numeric', month:'2-digit', day:'2-digit' }).replace(/\//g, '.');
  let md = '';

  md += `# ${holiday}æ´»åŠ¨ - æ’æœŸå®¡æ ¸ vs æ­£å¼ä¸Šçº¿ æ€»ç»“æŠ¥å‘Š\n\n`;
  md += `> å®¡æ ¸æ—¥æœŸï¼š${today}\n`;
  md += `> æ•°æ®æ¥æºï¼šæ’æœŸå®¡æ ¸è¡¨(xlsx) vs æ­£å¼ä¸Šçº¿è¡¨(csv)\n\n---\n\n`;

  // ä¸€ã€æ€»è§ˆ
  const xlsxCount = Object.keys(xlsxData.activities).length;
  const csvTotal = Object.values(csvData).reduce((s, v) => s + v.length, 0);
  const csvUnique = Object.keys(csvData).length;
  md += `## ä¸€ã€æ€»è§ˆ\n\n`;
  md += `| ç»´åº¦ | æ’æœŸå®¡æ ¸è¡¨ | æ­£å¼ä¸Šçº¿è¡¨ | è¯´æ˜ |\n|------|-----------|-----------|------|\n`;
  md += `| æ´»åŠ¨æ•° | ${xlsxCount}é¡¹ | ${csvTotal}æ¡è®°å½•(å»é‡å${csvUnique}ä¸ª) | ä¸Šçº¿è¡¨å«å¤šæœŸæ‹†åˆ† |\n\n---\n\n`;

  // äºŒã€æ´»åŠ¨æ¡ç›®åŒ¹é…
  md += `## äºŒã€æ´»åŠ¨æ¡ç›®åŒ¹é…ï¼ˆ${xlsxCount}é¡¹æ’æœŸ vs ä¸Šçº¿è¡¨ï¼‰\n\n`;
  md += `### âœ… å·²åŒ¹é…ï¼š${results.matched.length}é¡¹\n\n`;
  if (results.matched.length) {
    md += `| # | æ’æœŸå®¡æ ¸è¡¨ | è´Ÿè´£äºº | æ­£å¼ä¸Šçº¿è¡¨ | ä¸Šçº¿æ¡æ•° |\n|---|-----------|--------|-----------|:-------:|\n`;
    results.matched.forEach((m, i) => {
      const desc = m.items.length <= 2
        ? m.items.map(it => `${it.csvName}(${it.id})`).join(' + ')
        : `${m.items[0].csvName}(${m.items[0].id}) ç­‰${m.items.length}æ¡`;
      md += `| ${i + 1} | ${m.xName} | ${m.person} | ${desc} | ${m.count} |\n`;
    });
    md += '\n';
  }

  if (results.xlsxMissing.length) {
    md += `### âŒ æ’æœŸè¡¨æœ‰ä½†ä¸Šçº¿è¡¨ç¼ºå¤±ï¼š${results.xlsxMissing.length}é¡¹\n\n`;
    md += `| # | æ´»åŠ¨ | è´Ÿè´£äºº | è¯´æ˜ |\n|---|------|--------|------|\n`;
    results.xlsxMissing.forEach((m, i) => {
      md += `| ${i + 1} | **${m.name}** | ${m.person} | ${m.note} |\n`;
    });
    md += '\n';
  }

  if (results.csvMissing.length) {
    md += `### âŒ ä¸Šçº¿è¡¨æœ‰ä½†æ’æœŸè¡¨ç¼ºå¤±ï¼š${results.csvMissing.length}é¡¹\n\n`;
    md += `| æ´»åŠ¨ | ä¸Šçº¿æ¡æ•° | æ´»åŠ¨ID |\n|------|:-------:|--------|\n`;
    results.csvMissing.forEach(m => {
      md += `| **${m.name}** | ${m.count} | ${m.ids.slice(0, 5).join('/')}${m.ids.length > 5 ? '...' : ''} |\n`;
    });
    md += '\n';
  }
  md += `---\n\n`;

  // ä¸‰ã€ä¸Šçº¿æ—¶é—´å¯¹æ¯”
  md += `## ä¸‰ã€ä¸Šçº¿æ—¶é—´å¯¹æ¯”\n\n`;
  md += `### è§„å¾‹\n\næ’æœŸæ ‡è®°æ—¥ = éƒ¨ç½²æ“ä½œæ—¥ï¼Œå®é™…ä¸Šçº¿ = æ ‡è®°æ—¥ +${CFG.DEPLOY_OFFSET}å¤©\n\n`;

  if (results.timeWithMarks.length) {
    md += `### æœ‰æ—¥æœŸæ ‡è®°çš„æ´»åŠ¨é€æœŸæ¯”å¯¹\n\n`;
    for (const item of results.timeWithMarks) {
      md += `#### ${item.xName}ï¼ˆ${item.person}ï¼‰\n\n`;
      md += `æ’æœŸæ ‡è®°: ${item.marks.join(', ')}\n\n`;
      md += `| ä¸Šçº¿æ´»åŠ¨ | ID | ä¸Šçº¿æ—¶é—´ | æ—¶é•¿ | æ¯”å¯¹ç»“æœ |\n|---------|-----|---------|------|----------|\n`;
      for (const c of item.comparisons) {
        md += `| ${c.csvName} | ${c.csvId} | ${(c.start||'').slice(0,16)}~${(c.end||'').slice(0,16)} | ${c.duration} | ${c.result} |\n`;
      }
      md += '\n';
    }
  }

  if (results.timeWithoutMarks.length) {
    md += `### æ— æ—¥æœŸæ ‡è®°çš„æ´»åŠ¨ï¼ˆä»…åˆ—å‡ºä¸Šçº¿æ—¶é—´ï¼‰\n\n`;
    md += `| æ’æœŸæ´»åŠ¨ | ä¸Šçº¿æ´»åŠ¨ | ID | ä¸Šçº¿æ—¶é—´ | æ—¶é•¿ |\n|---------|---------|-----|---------|------|\n`;
    for (const item of results.timeWithoutMarks) {
      md += `| ${item.xName} | ${item.csvName} | ${item.csvId} | ${(item.start||'').slice(0,16)}~${(item.end||'').slice(0,16)} | ${item.duration} |\n`;
    }
    md += '\n';
  }
  md += `---\n\n`;

  // å››ã€æœåŠ¡å™¨é…ç½®å¯¹æ¯”
  md += `## å››ã€æœåŠ¡å™¨é…ç½®å¯¹æ¯”\n\n`;

  if (results.crossMismatch.length) {
    md += `### è·¨æœç±»å‹ä¸åŒ¹é…ï¼š${results.crossMismatch.length}é¡¹\n\n`;
    md += `| # | æ’æœŸæ´»åŠ¨ | ä¸Šçº¿æ´»åŠ¨ | æ’æœŸæ ‡æ³¨ | ä¸Šçº¿å®é™… | è¯´æ˜ |\n|---|---------|---------|---------|---------|------|\n`;
    results.crossMismatch.forEach((m, i) => {
      md += `| ${i + 1} | ${m.xName} | ${m.csvName} | ${m.xCross} | ${m.cCross} | ${m.note} |\n`;
    });
    md += '\n';
  }

  if (results.serverIssues.length) {
    md += `### æœåŠ¡å™¨æ•°é‡å¼‚å¸¸ï¼š${results.serverIssues.length}é¡¹\n\n`;
    md += `| # | æ´»åŠ¨ | ID | é¢„æœŸ | å®é™… | å·®å¼‚ | è¯´æ˜ |\n|---|------|----|:----:|:----:|:----:|------|\n`;
    results.serverIssues.forEach((m, i) => {
      md += `| ${i + 1} | ${m.csvName} | ${m.csvId} | ${m.expected} | ${m.actual} | ${m.diff > 0 ? '+' : ''}${m.diff} | ${m.note} |\n`;
    });
    md += '\n';
  }

  if (results.schemaSplits.length) {
    const allOk = results.schemaSplits.every(s => s.ok);
    md += `### Schema åˆ†å‰²å®Œæ•´æ€§ï¼š${allOk ? 'å…¨éƒ¨é€šè¿‡ âœ…' : 'å­˜åœ¨é—®é¢˜ âŒ'}\n\n`;
    md += `| Schema6 | Schema3-5 | S6æ•° | S35æ•° | åˆè®¡ | é‡å  | ç»“æœ |\n|---------|-----------|:----:|:-----:|:----:|:----:|------|\n`;
    results.schemaSplits.forEach(s => {
      md += `| ${s.s6} | ${s.s35} | ${s.s6Count} | ${s.s35Count} | ${s.combined} | ${s.overlap} | ${s.ok ? 'âœ…' : 'âŒ'} |\n`;
    });
    md += '\n';
  }
  md += '---\n\n';

  // äº”ã€å‘½åé—®é¢˜
  if (results.namingIssues.length) {
    md += `## äº”ã€æ´»åŠ¨å‘½åé—®é¢˜\n\n`;
    md += `| ä¸Šçº¿è¡¨æ´»åŠ¨å | ID | é—®é¢˜ |\n|-------------|-----|------|\n`;
    results.namingIssues.forEach(n => {
      md += `| **${n.csvName}** | ${n.ids.slice(0, 3).join('/')} | ${n.issue} |\n`;
    });
    md += '\n---\n\n';
  }

  // å…­ã€å¾…ç¡®è®¤äº‹é¡¹
  md += `## å…­ã€å¾…ç¡®è®¤äº‹é¡¹æ¸…å•\n\n`;
  const todos = [];
  results.xlsxMissing.forEach(m => todos.push({ pri: 'ğŸ”´é«˜', item: `**${m.name}** æ’æœŸæœ‰ä½†ä¸Šçº¿ç¼ºå¤±`, note: m.note }));
  results.csvMissing.filter(m => m.count >= 3).forEach(m => todos.push({ pri: 'ğŸ”´é«˜', item: `**${m.name}**(${m.count}æ¡) ä¸Šçº¿æœ‰ä½†æ’æœŸç¼ºå¤±`, note: 'æ˜¯å¦é—æ¼å®¡æ ¸ï¼Ÿ' }));
  if (results.crossMismatch.length) todos.push({ pri: 'ğŸŸ¡ä¸­', item: `${results.crossMismatch.length}é¡¹**è·¨æœç±»å‹ä¸åŒ¹é…**`, note: 'ç¡®è®¤å“ªæ–¹æ­£ç¡®' });
  if (results.serverIssues.length) todos.push({ pri: 'ğŸŸ¡ä¸­', item: `${results.serverIssues.length}é¡¹**æœåŠ¡å™¨æ•°é‡å¼‚å¸¸**`, note: 'ç¡®è®¤æ˜¯å¦æœ‰æ„ä¸ºä¹‹' });
  if (results.namingIssues.length) todos.push({ pri: 'ğŸŸ¢ä½', item: `${results.namingIssues.length}ä¸ªæ´»åŠ¨åç§°å¯èƒ½æœ‰è¯¯`, note: 'æ—§æ¨¡æ¿/å¹´ä»½é”™è¯¯' });

  if (todos.length) {
    md += `| åºå· | ä¼˜å…ˆçº§ | äº‹é¡¹ | è¯´æ˜ |\n|:----:|--------|------|------|\n`;
    todos.forEach((t, i) => md += `| ${i + 1} | ${t.pri} | ${t.item} | ${t.note} |\n`);
  } else {
    md += 'æ— å¾…ç¡®è®¤äº‹é¡¹ã€‚\n';
  }

  return md;
}

// ============================
// Utility
// ============================
function fmtDate(d, fmt) {
  if (!d) return '';
  const mm = String(d.getMonth() + 1).padStart(2, '0');
  const dd = String(d.getDate()).padStart(2, '0');
  if (fmt === 'MM.DD') return mm + '.' + dd;
  return d.getFullYear() + '.' + mm + '.' + dd;
}

function parseDateStr(s) {
  if (!s) return null;
  s = s.trim();
  const fmts = [
    /^(\d{4})\.(\d{1,2})\.(\d{1,2})\s+(\d{1,2}):(\d{2}):(\d{2})$/,
    /^(\d{4})\.(\d{1,2})\.(\d{1,2})$/,
    /^(\d{4})-(\d{1,2})-(\d{1,2})\s+(\d{1,2}):(\d{2}):(\d{2})$/,
    /^(\d{4})-(\d{1,2})-(\d{1,2})$/,
  ];
  for (const re of fmts) {
    const m = s.match(re);
    if (m) return new Date(+m[1], +m[2] - 1, +m[3], +(m[4]||0), +(m[5]||0), +(m[6]||0));
  }
  return null;
}

// ============================
// UI Actions
// ============================
async function startAnalysis() {
  showLoading('æ­£åœ¨è§£ææ–‡ä»¶...');

  try {
    const [xlsxBuf, csvBuf] = await Promise.all([
      xlsxFile.arrayBuffer(),
      csvFile.arrayBuffer(),
    ]);

    showLoading('è§£ææ’æœŸå®¡æ ¸è¡¨...');
    xlsxData = parseXlsx(xlsxBuf);

    showLoading('è§£ææ­£å¼ä¸Šçº¿è¡¨...');
    csvData = parseCsv(csvBuf);

    showLoading('è‡ªåŠ¨åŒ¹é…æ´»åŠ¨...');
    currentMapping = autoMatch(xlsxData.activities, csvData);

    renderMappingTable();
    goStep(2);
  } catch (err) {
    alert('è§£æå¤±è´¥: ' + err.message);
    goStep(1);
  }
}

function renderMappingTable() {
  const container = document.getElementById('mapping-container');
  const csvNames = Object.keys(csvData);
  let html = '<table class="mapping-table"><thead><tr><th>æ’æœŸè¡¨æ´»åŠ¨</th><th>è´Ÿè´£äºº</th><th>åŒ¹é…çš„ä¸Šçº¿è¡¨æ´»åŠ¨ï¼ˆå¯å¤šé€‰ï¼‰</th><th>çŠ¶æ€</th></tr></thead><tbody>';

  for (const [xName, selected] of Object.entries(currentMapping)) {
    const xa = xlsxData.activities[xName];
    if (!xa) continue;
    const status = selected.length > 0
      ? '<span class="tag tag-match">å·²åŒ¹é…</span>'
      : '<span class="tag tag-miss">æœªåŒ¹é…</span>';

    html += `<tr>
      <td style="font-weight:500;white-space:nowrap;">${xName}</td>
      <td style="color:var(--text-secondary);white-space:nowrap;">${xa.person}</td>
      <td>
        <select multiple size="${Math.min(5, Math.max(3, csvNames.length / 10 | 0))}" data-xlsx="${escapeHtml(xName)}" onchange="updateMapping(this)">
          ${csvNames.map(cn => `<option value="${escapeHtml(cn)}" ${selected.includes(cn) ? 'selected' : ''}>${cn} (${csvData[cn].length}æ¡)</option>`).join('')}
        </select>
      </td>
      <td>${status}</td>
    </tr>`;
  }

  html += '</tbody></table>';
  container.innerHTML = html;
}

function updateMapping(sel) {
  const xName = sel.getAttribute('data-xlsx');
  const selected = Array.from(sel.selectedOptions).map(o => o.value);
  currentMapping[xName] = selected;
}

function confirmMapping() {
  showLoading('æ­£åœ¨ç”Ÿæˆå®¡æ ¸æŠ¥å‘Š...');
  setTimeout(() => {
    try {
      const results = auditAll(xlsxData.activities, csvData, currentMapping);
      reportMarkdown = generateReport(results);
      document.getElementById('report-output').innerHTML = marked.parse(reportMarkdown);
      goStep(3);
    } catch (err) {
      alert('ç”ŸæˆæŠ¥å‘Šå¤±è´¥: ' + err.message);
      console.error(err);
      goStep(2);
    }
  }, 100);
}

function copyReport() {
  navigator.clipboard.writeText(reportMarkdown).then(() => {
    const btn = event.target;
    btn.textContent = 'âœ… å·²å¤åˆ¶';
    setTimeout(() => btn.textContent = 'ğŸ“‹ å¤åˆ¶ Markdown', 2000);
  });
}

function downloadReport() {
  const holiday = document.getElementById('cfg-holiday').value || 'èŠ‚æ—¥';
  const blob = new Blob([reportMarkdown], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${holiday}_æ’æœŸå®¡æ ¸æ€»ç»“æŠ¥å‘Š.md`;
  a.click();
  URL.revokeObjectURL(url);
}

function escapeHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}
</script>
</body>
</html>
